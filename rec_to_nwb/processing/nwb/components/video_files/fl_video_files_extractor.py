"""Returns the name, timestamps and device for each video file"""
import logging.config
import os

import numpy as np
import pandas as pd
from rec_to_binaries.read_binaries import readTrodesExtractedDataFile
from rec_to_nwb.processing.time.timestamp_converter import TimestampConverter
from rec_to_nwb.processing.tools.beartype.beartype import beartype

path = os.path.dirname(os.path.abspath(__file__))
logging.config.fileConfig(
    fname=os.path.join(str(path), os.pardir, os.pardir,
                       os.pardir, os.pardir, 'logging.conf'),
    disable_existing_loggers=False)
logger = logging.getLogger(__name__)


class FlVideoFilesExtractor:

    @beartype
    def __init__(self,
                 raw_data_path: str,
                 video_files_metadata: list,
                 preprocessing_path: str,
                 convert_timestamps: bool = True,
                 return_timestamps: bool = True):
        self.raw_data_path = raw_data_path
        self.video_files_metadata = video_files_metadata
        self.preprocessing_path = preprocessing_path
        self.convert_timestamps = convert_timestamps
        self.return_timestamps = return_timestamps

    def extract_video_files(self):
        """Returns the name, timestamps and device for each video file"""
        video_files = self.video_files_metadata
        extracted_video_files = []
        for video_file in video_files:
            if self.return_timestamps:
                timestamps = self._get_timestamps(video_file)
            else:
                timestamps = np.array([])
            new_fl_video_file = {
                "name": video_file["name"],
                "timestamps": timestamps,
                "device": video_file["camera_id"]
            }
            extracted_video_files.append(new_fl_video_file)
        return extracted_video_files

    def _get_timestamps(self, video_file):
        """Retrieves the video timestamps.

        Timestamps are in units of seconds and will be either relative to the
        start of the recording (if old dataset) or in seconds since 1/1/1970
        if precision time protocol (PTP) is used to synchronize the camera
        frames to Trodes data packets.

        Parameters
        ----------
        video_file : str

        Returns
        -------
        timestamps : ndarray

        """
        try:
            video_timestamps = self._read_video_timestamps_hw_sync(video_file)
            continuous_time = self._read_continuous_time(video_file)
            logger.info('Loaded cameraHWSync timestamps for'
                        f'{os.path.splitext(video_file["name"])[0]}')
            return TimestampConverter.convert_timestamps(
                continuous_time, video_timestamps)
        except FileNotFoundError:
            # old dataset
            video_timestamps = self._read_video_timestamps_hw_framecount(
                video_file)
            logger.info(
                'Loaded cameraHWFrameCount for '
                f'{os.path.splitext(video_file["name"])[0]} (old dataset)')
            return video_timestamps

    def _read_video_timestamps_hw_sync(self, video_file):
        """Returns the position timestamp index

        Parameters
        ----------
        video_file : str

        Returns
        -------
        unix_timestamps : ndarray

        """
        return readTrodesExtractedDataFile(
            os.path.join(
                self.raw_data_path,
                os.path.splitext(video_file["name"])[0] +
                ".videoTimeStamps.cameraHWSync")
        )['data']['PosTimestamp']

    def _read_video_timestamps_hw_framecount(self, video_file):
        """Returns the index of video frames.

        If PTP is not in use, only the videoTimeStamps.cameraHWFrameCount
        file is generated by the `rec_to_binaries` package.

        Parameters
        ----------
        video_file : str

        Returns
        -------
        index : ndarray

        """
        return readTrodesExtractedDataFile(
            os.path.join(
                self.raw_data_path,
                os.path.splitext(video_file["name"])[0] +
                ".videoTimeStamps.cameraHWFrameCount")
        )['data']['frameCount']

    def _read_continuous_time(self, video_file):
        base_name = os.path.splitext(video_file['name'])[0].split('.')[0]
        continuous_time_path = os.path.join(
            self.preprocessing_path, base_name + '.time',
            base_name + '.continuoustime.dat')

        continuous_time = readTrodesExtractedDataFile(continuous_time_path)
        return np.vstack((continuous_time['data']['trodestime'],
                          continuous_time['data']['adjusted_systime']))
